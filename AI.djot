# AI Assistant Specification

## Machine-Readable Artefacts

**CRITICAL**: The `.machine_readable/` directory contains **six structured Scheme files** that provide comprehensive project context. **Read these files at the start of every session** before doing any work on the codebase.

### Core Files

1. **STATE.scm** - Current project state
   - **Read when**: Session start (ALWAYS), before checking current progress
   - **Update when**: Tasks complete, blockers change, session ends
   - **Contains**: Milestones (35% complete), blockers (high/medium/low priority), critical next actions (immediate/week/month), session history, completion percentages per component

2. **META.scm** - Meta-level information and architecture decisions
   - **Read when**: Making design decisions, proposing architectural changes
   - **Update when**: Adding new ADRs, changing development practices, major design decisions
   - **Contains**: 8 ADRs (ISO EBNF, hybrid push/pull, dependent types, Elixir feedback loops, error handling, debugger repo, semantic versioning, Rust 2024), development practices (code style, security, testing, versioning, documentation, branching), design rationale (why VeriSimDB, why six modalities, why VQL, why drift-tolerant, why ZKP), cross-cutting concerns (performance, scalability, observability, security, ethics), future vision (v2+)

3. **ECOSYSTEM.scm** - Project's position in the ecosystem
   - **Read when**: Understanding project scope, considering integrations or dependencies
   - **Update when**: Adding dependencies, establishing relationships with other projects
   - **Contains**: Position in ecosystem (layer: infrastructure, role: core-database), related projects (verisimdb-debugger, vql-language-server, hypatia, oxigraph, proven, sactify-php, datomic, kafka, FAIR principles), what-this-is (multimodal federated database), what-this-is-not (NOT relational DB, NOT pure graph DB, NOT production-ready yet)

4. **PLAYBOOK.scm** - Operational procedures and runbooks
   - **Read when**: Implementing deployment, monitoring, backup, upgrade features
   - **Update when**: Adding new operational procedures, creating runbooks for new failure modes
   - **Contains**: Deployment playbooks (standalone, federated), operational runbooks (hexad-not-found, query-timeout, proof-generation-fails, federation-partition, disk-space-full), monitoring config (key metrics, alert rules, dashboards), backup procedures (full backup, incremental, restore), upgrade procedures (minor, major)

5. **AGENTIC.scm** - Agentic capabilities and autonomous behaviors
   - **Read when**: Implementing or modifying autonomous agents, understanding learning loops, agent coordination
   - **Update when**: Adding new agents, changing agent decision-making, modifying learning algorithms
   - **Contains**: Autonomous agents (drift-repair-agent, query-optimizer-agent, federation-coordinator-agent, cache-manager-agent), agent coordination (message-passing, conflict-resolution, supervision-tree), human-in-the-loop (approval-required, monitoring, override), learning & adaptation (feedback loops, exploration-exploitation, transfer-learning), safety constraints (hard-limits, invariants, fail-safe), future capabilities (v2: multiagent collaboration, v3: miniKanren integration, v3: LLM integration)

6. **NEUROSYM.scm** - Neurosymbolic architecture and hybrid reasoning
   - **Read when**: Working on type system, ZKP proofs, learning components, query optimization, drift classification
   - **Update when**: Adding symbolic reasoning (types, logic, proofs), adding subsymbolic learning (neural networks, embeddings), integrating symbolic + neural components
   - **Contains**: Neurosymbolic overview (motivation, symbolic components: VQL type system / ZKP proofs / miniKanren, subsymbolic components: vector embeddings / neural drift classifier / query latency predictor, hybrid reasoning patterns), symbolic reasoning (type-level reasoning: dependent types / refinement types, logic programming: miniKanren, proof theory: ZKP circuits / proof composition), subsymbolic learning (vector embeddings: semantic search / clustering / dimensionality reduction, neural classification: drift severity / query latency, reinforcement learning: cache TTL / federation routing), hybrid reasoning patterns (neural-suggests-symbolic-verifies, symbolic-guides-neural-training, neural-extracts-symbolic-rules, symbolic-neural-co-evolution), integration architecture (data-flow, component-interaction, feedback-loops), future capabilities (v2: neural query optimization, v3: miniKanren rule synthesis / LLM integration, v4: neuro-symbolic proofs)

Additional artefact:

- **AI.djot**: AI Assistant behavioral and operational instructions (this file)

### Session Start Protocol

**Before doing ANY work**, complete this checklist:

1. ✅ Read `.machine_readable/STATE.scm` - Know current progress, blockers, next actions
2. ✅ Check `.machine_readable/META.scm` - Review relevant ADRs for your task
3. ✅ Review `.machine_readable/ECOSYSTEM.scm` - Understand project relationships
4. ✅ Consult `.machine_readable/PLAYBOOK.scm` - If implementing operational features
5. ✅ Check `.machine_readable/AGENTIC.scm` - If working on agents or learning
6. ✅ Review `.machine_readable/NEUROSYM.scm` - If working on types, proofs, neural components

### Why These Files Matter

- **Context continuity**: Pick up where the last session left off without re-exploring the codebase
- **Design constraints**: Know what NOT to do (rejected ADRs, anti-patterns documented)
- **Architectural alignment**: Make decisions consistent with existing architecture (e.g., hybrid push/pull for normalization)
- **Learning from history**: See what was tried before, what worked, what didn't

## Repository Roots

- Local repository root: `/var/mnt/eclipse/repos`
- Remote mapping: `https://github.com/hyperpolymath/<name>`
- Repository names are lowercase; dots (`.`) are replaced with hyphens (`-`).
- If a repository is missing locally, check the remote and synchronize before proceeding.

## AI CLI Standards

- Include `ai-cli-crash-capture/` and `contractiles/` from this template in all new repositories.
- Mirror all 6SCM files into `.machine_readable/6scm/`.
- Before generating code, inspect `/var/mnt/eclipse/repos/proven` for the current Idris “unbreakable” library status.
- If the project depends on the unbreakable Idris library, add an *Idris Inside* badge to the repository.
- When new bindings are required, create them under `/var/mnt/eclipse/repos/proven` using the naming pattern `idris2-zig-<language>`.
- If new code implies additional unbreakable Idris modules, add them to `/var/mnt/eclipse/repos/proven` and update binders across all supported languages.

## Language Policy

### Allowed Languages and Tools

| Language/Tool | Use Case | Notes |
|---------------|----------|-------|
| ReScript | Application code | Type-safe, compiles to JS |
| Deno | Runtime and package management | Replaces Node/npm/bun |
| Rust | Systems, performance-critical, WASM | Preferred for CLI tools |
| Tauri 2.0+ | Mobile apps (iOS/Android) | Rust backend + web UI |
| Dioxus | Mobile apps (native UI) | Pure Rust, React-like |
| Gleam | Backend services | BEAM or JS targets |
| Bash/POSIX Shell | Automation scripts | Keep minimal |
| JavaScript | Only where ReScript cannot | MCP glue, Deno APIs |
| Nickel | Configuration | Complex config logic |
| Guile Scheme | Metadata/state files | For all `.scm` artefacts |
| Julia | Batch/data processing | Per RSR |
| OCaml | AffineScript compiler | Language-specific |
| Ada | Safety-critical systems | Where required |

### Banned Languages and Tools

| Banned | Replacement |
|--------|-------------|
| TypeScript | ReScript |
| Node.js | Deno |
| npm | Deno |
| Bun | Deno |
| pnpm/yarn | Deno |
| Go | Rust |
| Python | Julia / Rust / ReScript |
| Java/Kotlin | Rust / Tauri / Dioxus |
| Swift | Tauri / Dioxus |
| React Native | Tauri / Dioxus |
| Flutter/Dart | Tauri / Dioxus |

## Mobile Development Policy

A strict Rust-first approach applies.

- Use **Tauri 2.0+** for web UI (ReScript) + Rust backend.
- Use **Dioxus** for pure Rust native UI.

Both are FOSS with independent governance.

## Enforcement Rules

- Do not create new TypeScript files; convert existing TS to ReScript.
- Do not use `package.json` for runtime dependencies; use `deno.json` imports.
- Do not include `node_modules` in production; Deno handles dependency caching.
- Do not use Go; use Rust.
- Do not use Python; use Julia (data/batch), Rust (systems), or ReScript (apps).
- Do not use Kotlin/Swift; use Tauri 2.0+ or Dioxus for mobile.

## Package Management

- Primary: Guix (`guix.scm`)
- Fallback: Nix (`flake.nix`)
- JavaScript dependencies: Deno (`deno.json` imports)

## Security Requirements

- Do not use MD5 or SHA-1; use SHA-256 or stronger.
- Use HTTPS only.
- Do not hardcode secrets.
- Pin all dependencies by SHA.
- Include SPDX license headers in all files.
