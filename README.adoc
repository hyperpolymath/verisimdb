// SPDX-License-Identifier: PMPL-1.0-or-later

= VeriSimDB
:toc:
:toc-placement!:

**The Veridical Simulacrum Database** - A tiny core (<5k LOC) for universal federated knowledge.
Bridging the Map and the Territory.

toc::[]

== Overview

VeriSimDB is a **multimodal database with federation capabilities**. It can operate as a traditional standalone database OR as a federated coordinator—you choose the deployment mode that fits your needs.

=== Is VeriSimDB a Database?

**Yes.** VeriSimDB is a database that supports three deployment modes:

1. **Standalone** - Traditional database with all 6 modalities local (like PostgreSQL or MongoDB)
2. **Federated** - Coordinator for distributed stores across institutions
3. **Hybrid** - Some modalities local (fast), others federated (shared)

See link:docs/deployment-modes.adoc[Deployment Modes] for detailed comparison.

=== Core Capabilities

- **A Universal Namespace** - ReScript registry mapping 128-bit UUIDs to modality store locations
- **A Tiny Core** - Less than 5,000 lines of coordination logic (ReScript + Elixir)
- **KRaft-Inspired** - Replicated state machine with Raft consensus for metadata
- **Drift-Tolerant** - Continuous monitoring and repair across nodes (local or federated)
- **Zero-Trust** - Integration with `proven` (ZKP) and `sactify-php` for verifiable claims

=== What Makes It Different

Unlike traditional databases (single consistency model, single machine) or pure federation systems (no local storage), VeriSimDB:

- **Combines both** - Operates as database AND coordinator
- **Six modalities** - Graph, Vector, Tensor, Semantic, Document, Temporal in one system
- **Flexible deployment** - Start standalone, federate later (or vice versa)
- **Drift awareness** - Detects and repairs cross-modal inconsistencies

== Architecture

VeriSimDB's architecture adapts to your deployment mode. Below shows federated deployment; standalone mode collapses all stores to one system.

=== Federated Deployment

----
┌────────────────────────────────────────────────────────────────┐
│  ReScript Registry (Tiny Core)                                 │
│    ├── UUID → Store Mapping                                    │
│    ├── KRaft Metadata Log (Raft consensus)                     │
│    └── Trust Window Management                                 │
│              ↓ Federation Protocol                             │
├────────────────────────────────────────────────────────────────┤
│  Federated Stores (Independent Operators)                      │
│    ├── University Archive (Graph + Document)                   │
│    ├── Research Lab (Vector + Tensor)                          │
│    ├── Corporate DB (Semantic + Temporal)                      │
│    └── Community Node (All modalities)                         │
└────────────────────────────────────────────────────────────────┘
----

=== Standalone Deployment

----
┌─────────────────────────────────────────────────────────────┐
│  Elixir Orchestration Layer                                 │
│    ├── VeriSim.EntityServer (GenServer per Hexad)           │
│    ├── VeriSim.DriftMonitor (drift detection coordinator)   │
│    ├── VeriSim.QueryRouter (distributes queries)            │
│    └── VeriSim.SchemaRegistry (type system coordinator)     │
│              ↓ HTTP                                         │
├─────────────────────────────────────────────────────────────┤
│  Rust Modality Stores (All Local)                           │
│    ├── verisim-graph      ├── verisim-semantic              │
│    ├── verisim-vector     ├── verisim-document              │
│    ├── verisim-tensor     ├── verisim-temporal              │
│    ├── verisim-hexad      ├── verisim-drift                 │
│    └── verisim-normalizer └── verisim-api                   │
└─────────────────────────────────────────────────────────────┘
----

=== Six Modalities

Each **Hexad** (knowledge unit) can have representations across six modalities. In standalone mode, all modalities are local. In federated mode, they can be **distributed across stores**:

[cols="1,3"]
|===
|Modality |Purpose

|**Graph**
|RDF triples and property graph edges (Oxigraph)

|**Vector**
|Embeddings for similarity search (HNSW)

|**Tensor**
|Multi-dimensional numeric data (ndarray/Burn)

|**Semantic**
|Type annotations and CBOR proof blobs (proven + sactify-php)

|**Document**
|Full-text searchable content (Tantivy)

|**Temporal**
|Version history and time-series
|===

=== Reference Implementation

The reference implementation supports **all three deployment modes**. The stack shown above provides a complete standalone database that can optionally federate:

----
┌─────────────────────────────────────────────────────────────┐
│  Elixir Orchestration Layer                                 │
│    ├── VeriSim.EntityServer (GenServer per Hexad)           │
│    ├── VeriSim.DriftMonitor (drift detection coordinator)   │
│    ├── VeriSim.QueryRouter (distributes queries)            │
│    └── VeriSim.SchemaRegistry (type system coordinator)     │
│              ↓ HTTP                                         │
├─────────────────────────────────────────────────────────────┤
│  Rust Modality Crates (Optional Reference Stores)           │
│    ├── verisim-graph      ├── verisim-semantic              │
│    ├── verisim-vector     ├── verisim-document              │
│    ├── verisim-tensor     ├── verisim-temporal              │
│    ├── verisim-hexad      ├── verisim-drift                 │
│    └── verisim-normalizer └── verisim-api                   │
└─────────────────────────────────────────────────────────────┘
----

== Design Philosophy

VeriSimDB follows David Marr's three levels of analysis:

1. **Computational Level**: What problem are we solving?
   - Enable heterogeneous knowledge stores to federate without forced consistency
   - Detect and repair drift across institutional boundaries
   - Provide verifiable, tamper-evident knowledge exchange

2. **Algorithmic Level**: How do we solve it?
   - Hexad namespace: one UUID, N federated modality representations
   - KRaft-inspired metadata log with Raft consensus
   - Drift detection with configurable repair policies
   - ZKP integration for privacy-preserving verification

3. **Implementational Level**: How is it built?
   - ReScript for type-safe registry logic (compiles to WASM)
   - Elixir/OTP for fault-tolerant coordination
   - Rust for reference modality implementations
   - Proven + sactify-php for Zero-Trust security

== Quick Start

=== Prerequisites

* Rust (edition 2024)
* Elixir 1.17+
* nerdctl, with Podman fallback for containerisation

=== Build Reference Implementation

[source,bash]
----
# Rust reference stores
cargo build

# Elixir orchestration
cd elixir-orchestration
mix deps.get
mix compile
----

=== Run

[source,bash]
----
# Start Rust API server (reference stores)
cargo run -p verisim-api

# Start Elixir orchestration (in another terminal)
cd elixir-orchestration
iex -S mix
----

=== Container

[source,bash]
----
podman build -t verisimdb:latest -f container/Containerfile .
podman run -p 8080:8080 verisimdb:latest
----

== API Examples

=== Register a Hexad in the Namespace

[source,bash]
----
curl -X POST http://localhost:8080/api/v1/registry/hexads \
  -H "Content-Type: application/json" \
  -d '{
    "hexad_id": "550e8400-e29b-41d4-a716-446655440000",
    "store_endpoint": "https://university-archive.edu/verisim",
    "modalities": ["graph", "document", "temporal"],
    "policy_hash": "sha256:abc123..."
  }'
----

=== Create a Hexad (in Reference Store)

[source,bash]
----
curl -X POST http://localhost:8080/api/v1/hexads \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Machine Learning Paper",
    "body": "An introduction to neural networks...",
    "embedding": [0.1, 0.2, ...],
    "types": ["http://example.org/Paper"],
    "relationships": [["cites", "paper-123"]]
  }'
----

=== Query Across Federated Stores

[source,bash]
----
curl "http://localhost:8080/api/v1/federation/search?q=neural+networks&modalities=document,vector&limit=10"
----

=== Verify ZKP (without data access)

[source,bash]
----
curl -X POST http://localhost:8080/api/v1/verify/zkp \
  -H "Content-Type: application/json" \
  -d '{
    "hexad_id": "550e8400-e29b-41d4-a716-446655440000",
    "contract": "CitationContract",
    "witness": "0x1a2b3c..."
  }'
----

== Project Structure

----
verisimdb/
├── Cargo.toml                 # Rust workspace
├── rust-core/                 # Reference store implementations
│   ├── verisim-graph/         # Graph modality (Oxigraph)
│   ├── verisim-vector/        # Vector modality (HNSW)
│   ├── verisim-tensor/        # Tensor modality (ndarray)
│   ├── verisim-semantic/      # Semantic modality (CBOR + ZKP)
│   ├── verisim-document/      # Document modality (Tantivy)
│   ├── verisim-temporal/      # Temporal modality (versions)
│   ├── verisim-hexad/         # Unified Hexad entity
│   ├── verisim-drift/         # Drift detection
│   ├── verisim-normalizer/    # Self-normalization
│   └── verisim-api/           # HTTP API server
├── registry/                  # ReScript registry (tiny core)
│   ├── src/
│   │   ├── Registry.res       # UUID → Store mapping
│   │   ├── KRaftLog.res       # Metadata consensus log
│   │   └── TrustWindow.res    # Ephemeral key management
│   └── rescript.json
├── elixir-orchestration/      # Elixir/OTP layer
│   ├── lib/verisim/
│   ├── config/
│   └── mix.exs
├── container/                 # Containerfiles
├── docs/                      # Documentation
│   ├── WHITEPAPER.md          # Architecture rationale
│   ├── Technical Specification - KRaft Metadata Log.md
│   └── ZKP and Sanctify Integration.md
└── .machine_readable/         # STATE.scm, META.scm, ECOSYSTEM.scm
----

== Key Documentation

- link:WHITEPAPER.md[White Paper] - Architecture rationale and federation design
- link:docs/deployment-modes.adoc[Deployment Modes] - Standalone vs Federated vs Hybrid
- link:docs/technical-specification-kraft-metadata-log.adoc[KRaft Integration] - Metadata consensus protocol
- link:docs/zkp-and-sanctify-integration.adoc[Zero-Trust Security] - ZKP verification with proven + sactify-php
- link:docs/rescript-registry-types.adoc[Registry Types] - ReScript type definitions
- link:docs/snapshotting-and-truncation-logic.adoc[Snapshotting] - Log truncation and recovery
- link:Kraft%20cross-integration%20to%20VeriSim.csv[KRaft Comparison] - VeriSimDB vs Kafka KRaft

== Use Cases

=== Open Science Federation
Universities and research institutions federate their archives while maintaining local control. Drift detection ensures retractions propagate correctly.

=== Neurosymbolic AI Pipelines
Vector embeddings and symbolic graphs coexist in the same namespace. AI systems query both modalities without ETL.

=== FAIR Data Compliance
Funding agencies require verifiable provenance. ZKP proofs demonstrate compliance without exposing sensitive data.

=== Decentralized Web (Web3)
Community-governed knowledge stores with tamper-evident audit trails and cryptographic verification.

== License

PMPL-1.0-or-later

== Contributing

See CONTRIBUTING.adoc for guidelines.
