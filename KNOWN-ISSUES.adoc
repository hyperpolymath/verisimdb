// SPDX-License-Identifier: PMPL-1.0-or-later
// Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk>

= Known Issues and Honest Gaps
:toc: left
:toclevels: 2
:sectnums:

== Overview

This document lists known issues, incomplete implementations, and honest gaps in VeriSimDB as of 2026-02. Each entry describes the current state, why it matters, and what needs to happen to resolve it.

VeriSimDB is a working system with real implementations in its core modality stores, but several higher-level features are stubs or partially implemented. This document does not hide behind "future work" euphemisms -- it states plainly what does not work.

== Issues

=== 1. Normalizer Regeneration Strategies Are Stubs — ✅ RESOLVED

**Location:** `rust-core/verisim-normalizer/`

**Resolved:** 2026-02-12. Regeneration strategies now inspect hexad data to select the authoritative modality and derive drifted modality content from it, rather than returning hardcoded placeholder strings. Each of the six modality strategies performs actual data transformation.

**Original issue:** Every regeneration strategy returned a hardcoded `[regenerated]` placeholder string instead of actually regenerating data.

=== 2. Federation Executor Always Returns Empty — ✅ RESOLVED

**Location:** Elixir orchestration layer, `VeriSim.FederationExecutor`

**Resolved:** 2026-02-12. Federation executor now performs parallel HTTP fanout to registered peers via reqwest, decomposes queries into per-peer sub-queries, dispatches them, and merges results. Uses `Task.async_stream` for concurrent peer dispatch with configurable timeouts.

**Original issue:** The federation executor always returned `{:ok, []}` regardless of query content or number of registered peers.

=== 3. Federation Resolver Peer Queries Unimplemented — ✅ RESOLVED

**Location:** Elixir orchestration layer, `VeriSim.Federation.Resolver`

**Resolved:** 2026-02-12. `query_peer/3` now makes real HTTP requests to peer endpoints via `Req` with configurable timeout, parses JSON responses, and returns structured results with source store attribution and response time tracking. Drift policy filtering (strict/repair/tolerate/latest) is implemented.

**Original issue:** The `query_peer/3` function returned `{:error, :not_implemented}`. Peers could be registered but never contacted.

=== 4. Drift Auto-Trigger Missing — ✅ RESOLVED

**Location:** Elixir orchestration layer, `VeriSim.DriftMonitor`

**Resolved:** 2026-02-12. `DriftMonitor.init/1` now schedules a periodic sweep via `Process.send_after` at a configurable interval (default 60s). The `:sweep` handler performs a full drift sweep including pulling aggregate metrics from the Rust core via `RustClient.drift_status/0`, then reschedules itself. The sweep interval is configurable via the `config` option passed to `start_link`.

**Original issue:** Drift detection had to be triggered manually. No scheduled or event-driven trigger existed.

=== 5. GQL-DT Not Connected to VQL PROOF Runtime

**Location:** `gql-dt/` (Lean type definitions), VQL query router

**Current state:** Lean type definitions exist in the `gql-dt/` directory specifying dependent type contracts for all six PROOF types (EXISTENCE, INTEGRITY, CONSISTENCY, PROVENANCE, FRESHNESS, AUTHORIZATION). The VQL parser correctly parses `PROOF` clauses and the query router routes to the dependent-type execution path. However, the Lean type checker is not invoked at runtime. VQL-DT queries execute but do not generate real proof certificates.

**Impact:** The `PROOF` clause is syntactically supported but semantically inert. Queries with `PROOF` clauses return data but the accompanying proof certificates are placeholders, not verifiable. This is the gap between the designed architecture and the current implementation.

**Resolution:** Wire the Lean type checker into the VQL-DT execution path. This requires: (a) compiling Lean definitions to an executable checker, (b) generating proof obligations from the VQL AST, (c) invoking the checker and collecting proof witnesses from modality stores, (d) assembling and returning verifiable proof certificates. See link:docs/vql-vs-vql-dt.adoc[VQL Slipstream vs VQL-DT] for the phased roadmap.

=== 6. ZKP / Proven Library Not Integrated

**Location:** `docs/zkp-and-sanctify-integration.adoc` (design), `proven-coherence.md` (notes)

**Current state:** The integration of zero-knowledge proofs via the sanctify library is documented as a consultation paper and design specification. The integration is not implemented. No ZKP circuits are generated, no proofs are created, and no verification occurs at runtime.

**Impact:** Privacy-preserving proofs (where a query result can be verified without revealing the underlying data) are not available. This affects multi-tenant federation and compliance scenarios where data must remain private but provenance must be verifiable.

**Resolution:** Implement sanctify integration after VQL-DT (issue 5) is resolved, since ZKP proof generation depends on the dependent type checking pipeline being functional.

=== 7. ReScript Registry 60% Complete

**Location:** ReScript source files (type definitions and registry bindings)

**Current state:** Type definitions for the ReScript schema registry are complete. These define the types for hexad entities, modality metadata, drift scores, and federation configuration. Runtime bindings (the code that connects ReScript types to the Rust core and Elixir orchestration layer) are partially implemented.

**Impact:** The schema registry cannot be fully managed from the ReScript layer. Some registry operations require direct Elixir or Rust API calls instead of going through the typed ReScript interface.

**Resolution:** Complete the remaining runtime bindings for registry CRUD operations, drift policy management, and federation configuration.

=== 8. `debugger/Cargo.toml` Had Wrong Author

**Location:** `debugger/Cargo.toml`

**Current state:** Fixed. The `debugger/Cargo.toml` previously listed an incorrect author. It now correctly reads `authors = ["Jonathan D.A. Jewell <jonathan.jewell@open.ac.uk>"]`.

**Impact:** None (resolved). Documented here for audit trail completeness.

=== 9. HNSW Implementation Is Real

**Location:** `rust-core/verisim-vector/src/hnsw.rs`

**Current state:** The HNSW (Hierarchical Navigable Small World) implementation in `verisim-vector` is a genuine, functional implementation at approximately 670 lines of Rust. A previous audit incorrectly claimed this was brute-force search. This is **not** an issue -- it is a correction of a previous mischaracterization.

**Impact:** None (this is a positive clarification). The vector modality store uses a real approximate nearest-neighbor algorithm, not a naive linear scan.

**Note:** This entry exists to prevent future audits from repeating the same incorrect claim.

=== 10. verisim-api Needs Bin Target Fix — ✅ RESOLVED

**Location:** `rust-core/verisim-api/Cargo.toml`

**Resolved:** 2026-02-12. `src/main.rs` now exists with a `main()` function that reads host/port from environment variables (`VERISIM_HOST`/`VERISIM_PORT`) and initializes the HTTP server. `cargo run -p verisim-api` works.

**Original issue:** The crate was missing a `src/main.rs` entry point and could not be run as a standalone binary.

=== 11. No Performance Baselines Established

**Location:** `benches/` (benchmark harness exists but is minimal)

**Current state:** No systematic benchmarks have been run for any modality store. There are no established baselines for: HNSW query latency, graph traversal throughput, document indexing speed, tensor operation performance, semantic store read/write times, or temporal version retrieval.

**Impact:** Without baselines, it is impossible to detect performance regressions, set SLOs, or make informed optimization decisions. Claims about VeriSimDB's performance are anecdotal, not measured.

**Resolution:** Write benchmarks for each modality store using Criterion (Rust). Establish baseline numbers on reference hardware. Add benchmark runs to CI with regression detection. Prioritize HNSW (vector) and Tantivy (document) benchmarks since these are the most latency-sensitive stores.

=== 12. Cross-Modal Drift/Consistency Were Stubs — ✅ RESOLVED

**Location:** `elixir-orchestration/lib/verisim/query/vql_executor.ex`

**Resolved:** 2026-02-13. `compute_modality_drift/3` now fetches drift from the Rust drift API when available, falling back to cosine distance between extracted modality embeddings (with content fingerprinting for non-vector modalities). `compute_consistency/4` now computes real scores using the specified metric (COSINE, EUCLIDEAN, DOT_PRODUCT, JACCARD). Both functions previously returned hardcoded constants (0.0 and 0.5).

**Original issue:** Cross-modal correlation queries parsed correctly but evaluation returned fake scores, making WHERE DRIFT(...) and CONSISTENT(...) conditions meaningless.

=== 13. VQL WHERE Condition Routing Was Broken — ✅ RESOLVED

**Location:** `elixir-orchestration/lib/verisim/query/vql_executor.ex`

**Resolved:** 2026-02-13. `has_fulltext_condition?/1`, `has_vector_condition?/1`, and `has_graph_pattern?/1` now walk the AST recursively to detect actual condition types. `extract_text_query/1`, `extract_vector_query/1`, and `extract_graph_query/1` now parse actual values from the AST instead of returning hardcoded placeholders. All queries were previously routed to `:multi` type regardless of conditions.

**Original issue:** All six condition detection and extraction functions were stubs (returning `false` and hardcoded values), causing every query to be routed as a multi-modal query even when a single modality was targeted.

=== 14. Proof Verification Was No-Op — ✅ RESOLVED

**Location:** `elixir-orchestration/lib/verisim/query/vql_executor.ex`

**Resolved:** 2026-02-13. `verify_single_proof/1` now validates proof type, extracts contract names, and checks contract existence against the semantic store. It properly rejects queries with invalid or missing contracts for CITATION, INTEGRITY, and CUSTOM proof types. Previously it always returned `:ok`.

**Original issue:** PROOF clauses in VQL queries were parsed but never verified. All proofs silently passed, making the entire proof system decorative.

=== 15. believe_me in Idris2 ABI Files — ✅ RESOLVED

**Location:** `src/abi/Foreign.idr`, `debugger/src/abi/Foreign.idr`, `practice-mirror/src/abi/Foreign.idr`

**Resolved:** 2026-02-13. FFI declarations changed from `Bits64 -> AnyPtr -> PrimIO Bits32` to `Bits64 -> (Bits64 -> Bits32 -> Bits32) -> PrimIO Bits32`, making the callback type match the declaration and eliminating the need for `believe_me` casts. Zero `believe_me` calls remain in the codebase.

**Original issue:** `registerCallback` used `believe_me` to cast a callback function to `AnyPtr`, a BANNED unsafe pattern that bypasses the type checker.

=== 16. Atom Table Exhaustion Risk in VQL Bridge — ✅ RESOLVED

**Location:** `elixir-orchestration/lib/verisim/query/vql_bridge.ex`

**Resolved:** 2026-02-13. All 8 `String.to_atom` calls replaced with `safe_to_atom/1` helper that uses an explicit allowlist map for the known atom values (6 modalities + 5 aggregate functions + `all`), falling back to `String.to_existing_atom/1`.

**Original issue:** 8 `String.to_atom` calls could theoretically exhaust the BEAM atom table if fed arbitrary input, since the BEAM atom table is finite and atoms are never garbage collected.

=== 17. No ETS Caching in RustClient — ✅ RESOLVED

**Location:** `elixir-orchestration/lib/verisim/rust_client.ex`

**Resolved:** 2026-02-13. Added ETS-based read-through cache with configurable TTL (30s default for hexads, 10s for drift scores). Cache is invalidated on writes (update/delete). Provides `init_cache/0`, `clear_cache/0`, and `invalidate_cache/1` for cache management.

**Original issue:** Every RustClient call made a fresh HTTP request to the Rust core, with no caching. Repeated reads of the same hexad in a query pipeline (e.g., cross-modal evaluation fetching the same entity multiple times) each incurred full HTTP round-trip latency.

=== 18. EXPLAIN Returns Hardcoded Plan — ✅ RESOLVED

**Location:** `elixir-orchestration/lib/verisim/query/vql_executor.ex`

**Resolved:** 2026-02-13. `generate_explain_plan/1` now analyzes the actual query AST to produce cost estimates based on source type, modality count, WHERE clause complexity, cross-modal conditions, GROUP BY presence, and proof obligations. Delegates to the Rust verisim-planner API when available, with local estimation as fallback.

**Original issue:** EXPLAIN returned a static plan with hardcoded step names and costs totalling 71ms, regardless of the actual query structure.

=== 19. VQL Executor Federation Stub — ✅ RESOLVED

**Location:** `elixir-orchestration/lib/verisim/query/vql_executor.ex`, `rust-core/verisim-api/src/federation.rs`

**Resolved:** 2026-02-13. Added `GET /hexads` list endpoint with `?limit=N&offset=M` pagination to the Rust API. The `HexadStore` trait now includes a `list(limit, offset)` method. Federation `query_single_peer()` now falls back to the `/hexads` list endpoint when neither text_query nor vector_query is provided, so bare `SELECT * FROM FEDERATION /pattern/*` returns actual hexad data instead of empty results.

=== 20. Custom Circuit Hardcoding

**Location:** `rust-core/verisim-semantic/src/zkp.rs`

**Current state:** The `CUSTOM` proof type in VQL uses a hardcoded circuit configuration. There is no circuit DSL, no compilation pipeline, no circuit registry, and no parameterization. All custom proofs use the same default circuit regardless of the contract name specified.

**Impact:** The CUSTOM proof type is syntactically supported but semantically identical to an existence check. Users cannot define actual custom ZKP circuits.

**Resolution:** Implement the Custom Circuits infrastructure: circuit DSL, compilation pipeline, circuit registry, parameterization, and verification key management. This is the next major feature to build.
