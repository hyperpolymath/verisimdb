// SPDX-License-Identifier: PMPL-1.0-or-later
// Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk>

= Known Issues and Honest Gaps
:toc: left
:toclevels: 2
:sectnums:

== Overview

This document lists known issues, incomplete implementations, and honest gaps in VeriSimDB as of 2026-02-13. Each entry describes the current state, why it matters, and what needs to happen to resolve it.

A major 7-phase hardening effort was completed on 2026-02-13, resolving most previously-open issues. The remaining open items are documented below.

VeriSimDB is a working system with real implementations in its core modality stores, but several higher-level features are stubs or partially implemented. This document does not hide behind "future work" euphemisms -- it states plainly what does not work.

== Issues

=== 1. Normalizer Regeneration Strategies Are Stubs — ✅ RESOLVED

**Location:** `rust-core/verisim-normalizer/`

**Resolved:** 2026-02-12. Regeneration strategies now inspect hexad data to select the authoritative modality and derive drifted modality content from it, rather than returning hardcoded placeholder strings. Each of the six modality strategies performs actual data transformation.

**Original issue:** Every regeneration strategy returned a hardcoded `[regenerated]` placeholder string instead of actually regenerating data.

=== 2. Federation Executor Always Returns Empty — ✅ RESOLVED

**Location:** Elixir orchestration layer, `VeriSim.FederationExecutor`

**Resolved:** 2026-02-12. Federation executor now performs parallel HTTP fanout to registered peers via reqwest, decomposes queries into per-peer sub-queries, dispatches them, and merges results. Uses `Task.async_stream` for concurrent peer dispatch with configurable timeouts.

**Original issue:** The federation executor always returned `{:ok, []}` regardless of query content or number of registered peers.

=== 3. Federation Resolver Peer Queries Unimplemented — ✅ RESOLVED

**Location:** Elixir orchestration layer, `VeriSim.Federation.Resolver`

**Resolved:** 2026-02-12. `query_peer/3` now makes real HTTP requests to peer endpoints via `Req` with configurable timeout, parses JSON responses, and returns structured results with source store attribution and response time tracking. Drift policy filtering (strict/repair/tolerate/latest) is implemented.

**Original issue:** The `query_peer/3` function returned `{:error, :not_implemented}`. Peers could be registered but never contacted.

=== 4. Drift Auto-Trigger Missing — ✅ RESOLVED

**Location:** Elixir orchestration layer, `VeriSim.DriftMonitor`

**Resolved:** 2026-02-12. `DriftMonitor.init/1` now schedules a periodic sweep via `Process.send_after` at a configurable interval (default 60s). The `:sweep` handler performs a full drift sweep including pulling aggregate metrics from the Rust core via `RustClient.drift_status/0`, then reschedules itself. The sweep interval is configurable via the `config` option passed to `start_link`.

**Original issue:** Drift detection had to be triggered manually. No scheduled or event-driven trigger existed.

=== 5. VQL-DT Not Connected to VQL PROOF Runtime

**Location:** `vql-dt/` (Lean type definitions), VQL query router

**Current state:** Lean type definitions exist in the `vql-dt/` directory specifying dependent type contracts for all six PROOF types (EXISTENCE, INTEGRITY, CONSISTENCY, PROVENANCE, FRESHNESS, AUTHORIZATION). The VQL parser correctly parses `PROOF` clauses and the query router routes to the dependent-type execution path. However, the Lean type checker is not invoked at runtime. VQL-DT queries execute but do not generate real proof certificates.

**Impact:** The `PROOF` clause is syntactically supported but semantically inert. Queries with `PROOF` clauses return data but the accompanying proof certificates are placeholders, not verifiable. This is the gap between the designed architecture and the current implementation.

**Resolution:** Wire the Lean type checker into the VQL-DT execution path. This requires: (a) compiling Lean definitions to an executable checker, (b) generating proof obligations from the VQL AST, (c) invoking the checker and collecting proof witnesses from modality stores, (d) assembling and returning verifiable proof certificates. See link:docs/vql-vs-vql-dt.adoc[VQL Slipstream vs VQL-DT] for the phased roadmap.

=== 6. ZKP / Proven Library Not Integrated

**Location:** `docs/zkp-and-sanctify-integration.adoc` (design), `proven-coherence.md` (notes)

**Current state:** The integration of zero-knowledge proofs via the sanctify library is documented as a consultation paper and design specification. The integration is not implemented. No ZKP circuits are generated, no proofs are created, and no verification occurs at runtime.

**Impact:** Privacy-preserving proofs (where a query result can be verified without revealing the underlying data) are not available. This affects multi-tenant federation and compliance scenarios where data must remain private but provenance must be verifiable.

**Resolution:** Implement sanctify integration after VQL-DT (issue 5) is resolved, since ZKP proof generation depends on the dependent type checking pipeline being functional.

=== 7. ReScript Registry 60% Complete — ✅ RESOLVED

**Location:** `src/registry/Registry.res`, `rescript.json`

**Resolved:** 2026-02-13. All 7 previously stubbed functions now have real implementations:

- `executeFederatedQuery`: HTTP fan-out to eligible peer stores with trust filtering, response mapping, and result aggregation with limit enforcement.
- `achieveConsensus`: Quorum-based consensus with configurable mode (Strong/Quorum/Eventual), concurrent store fetch, agreement calculation.
- `replicateHexad`: Fetches hexad from source store via HTTP, pushes to all target stores, reports per-target errors.
- `checkReplicationStatus`: Examines mapping locations, checks store liveness against maxStoreDowntimeMs, detects trust divergence as data divergence proxy.
- `detectByzantineFaults`: Computes median trust across stores for a hexad, flags stores deviating >0.3 from median.
- `serializeRegistry`/`deserializeRegistry`: Full JSON serialization and deserialization of registry state (stores, mappings, config).

Added `rescript.json` for build configuration.

=== 8. `debugger/Cargo.toml` Had Wrong Author

**Location:** `debugger/Cargo.toml`

**Current state:** Fixed. The `debugger/Cargo.toml` previously listed an incorrect author. It now correctly reads `authors = ["Jonathan D.A. Jewell <jonathan.jewell@open.ac.uk>"]`.

**Impact:** None (resolved). Documented here for audit trail completeness.

=== 9. HNSW Implementation Is Real

**Location:** `rust-core/verisim-vector/src/hnsw.rs`

**Current state:** The HNSW (Hierarchical Navigable Small World) implementation in `verisim-vector` is a genuine, functional implementation at approximately 670 lines of Rust. A previous audit incorrectly claimed this was brute-force search. This is **not** an issue -- it is a correction of a previous mischaracterization.

**Impact:** None (this is a positive clarification). The vector modality store uses a real approximate nearest-neighbor algorithm, not a naive linear scan.

**Note:** This entry exists to prevent future audits from repeating the same incorrect claim.

=== 10. verisim-api Needs Bin Target Fix — ✅ RESOLVED

**Location:** `rust-core/verisim-api/Cargo.toml`

**Resolved:** 2026-02-12. `src/main.rs` now exists with a `main()` function that reads host/port from environment variables (`VERISIM_HOST`/`VERISIM_PORT`) and initializes the HTTP server. `cargo run -p verisim-api` works.

**Original issue:** The crate was missing a `src/main.rs` entry point and could not be run as a standalone binary.

=== 11. No Performance Baselines Established — ✅ RESOLVED

**Location:** `benches/modality_benchmarks.rs`

**Resolved:** 2026-02-13. Criterion benchmarks now cover all 6 modality stores plus cross-modal and drift operations:

- **Document:** create_document, search_text (Tantivy full-text, 1000-doc corpus)
- **Vector:** insert (128/384/768 dims), search (10k vectors, HNSW)
- **Graph:** add_node, add_edge (Oxigraph)
- **Tensor:** store_create_64x64, store_get, reduce_sum_axis0 (ndarray)
- **Semantic:** register_type, get_type, proof_create_cbor, proof_verify (CBOR + ZKP verification)
- **Temporal:** version_create, version_get_by_number, version_get_latest, history_10, history_100
- **Hexad:** create_hexad, get_hexad (unified entity)
- **Drift:** calculate_drift (semantic vector drift)
- **Cross-modal:** vector_similarity_search, fulltext_search (1000 multi-modal hexads)

**Original issue:** Only document, vector, graph, hexad, drift, and cross-modal benchmarks existed. Tensor, semantic, and temporal stores had zero benchmarks.

=== 12. Cross-Modal Drift/Consistency Were Stubs — ✅ RESOLVED

**Location:** `elixir-orchestration/lib/verisim/query/vql_executor.ex`

**Resolved:** 2026-02-13. `compute_modality_drift/3` now fetches drift from the Rust drift API when available, falling back to cosine distance between extracted modality embeddings (with content fingerprinting for non-vector modalities). `compute_consistency/4` now computes real scores using the specified metric (COSINE, EUCLIDEAN, DOT_PRODUCT, JACCARD). Both functions previously returned hardcoded constants (0.0 and 0.5).

**Original issue:** Cross-modal correlation queries parsed correctly but evaluation returned fake scores, making WHERE DRIFT(...) and CONSISTENT(...) conditions meaningless.

=== 13. VQL WHERE Condition Routing Was Broken — ✅ RESOLVED

**Location:** `elixir-orchestration/lib/verisim/query/vql_executor.ex`

**Resolved:** 2026-02-13. `has_fulltext_condition?/1`, `has_vector_condition?/1`, and `has_graph_pattern?/1` now walk the AST recursively to detect actual condition types. `extract_text_query/1`, `extract_vector_query/1`, and `extract_graph_query/1` now parse actual values from the AST instead of returning hardcoded placeholders. All queries were previously routed to `:multi` type regardless of conditions.

**Original issue:** All six condition detection and extraction functions were stubs (returning `false` and hardcoded values), causing every query to be routed as a multi-modal query even when a single modality was targeted.

=== 14. Proof Verification Was No-Op — ✅ RESOLVED

**Location:** `elixir-orchestration/lib/verisim/query/vql_executor.ex`

**Resolved:** 2026-02-13. `verify_single_proof/1` now validates proof type, extracts contract names, and checks contract existence against the semantic store. It properly rejects queries with invalid or missing contracts for CITATION, INTEGRITY, and CUSTOM proof types. Previously it always returned `:ok`.

**Original issue:** PROOF clauses in VQL queries were parsed but never verified. All proofs silently passed, making the entire proof system decorative.

=== 15. believe_me in Idris2 ABI Files — ✅ RESOLVED

**Location:** `src/abi/Foreign.idr`, `debugger/src/abi/Foreign.idr`, `practice-mirror/src/abi/Foreign.idr`

**Resolved:** 2026-02-13. FFI declarations changed from `Bits64 -> AnyPtr -> PrimIO Bits32` to `Bits64 -> (Bits64 -> Bits32 -> Bits32) -> PrimIO Bits32`, making the callback type match the declaration and eliminating the need for `believe_me` casts. Zero `believe_me` calls remain in the codebase.

**Original issue:** `registerCallback` used `believe_me` to cast a callback function to `AnyPtr`, a BANNED unsafe pattern that bypasses the type checker.

=== 16. Atom Table Exhaustion Risk in VQL Bridge — ✅ RESOLVED

**Location:** `elixir-orchestration/lib/verisim/query/vql_bridge.ex`

**Resolved:** 2026-02-13. All 8 `String.to_atom` calls replaced with `safe_to_atom/1` helper that uses an explicit allowlist map for the known atom values (6 modalities + 5 aggregate functions + `all`), falling back to `String.to_existing_atom/1`.

**Original issue:** 8 `String.to_atom` calls could theoretically exhaust the BEAM atom table if fed arbitrary input, since the BEAM atom table is finite and atoms are never garbage collected.

=== 17. No ETS Caching in RustClient — ✅ RESOLVED

**Location:** `elixir-orchestration/lib/verisim/rust_client.ex`

**Resolved:** 2026-02-13. Added ETS-based read-through cache with configurable TTL (30s default for hexads, 10s for drift scores). Cache is invalidated on writes (update/delete). Provides `init_cache/0`, `clear_cache/0`, and `invalidate_cache/1` for cache management.

**Original issue:** Every RustClient call made a fresh HTTP request to the Rust core, with no caching. Repeated reads of the same hexad in a query pipeline (e.g., cross-modal evaluation fetching the same entity multiple times) each incurred full HTTP round-trip latency.

=== 18. EXPLAIN Returns Hardcoded Plan — ✅ RESOLVED

**Location:** `elixir-orchestration/lib/verisim/query/vql_executor.ex`

**Resolved:** 2026-02-13. `generate_explain_plan/1` now analyzes the actual query AST to produce cost estimates based on source type, modality count, WHERE clause complexity, cross-modal conditions, GROUP BY presence, and proof obligations. Delegates to the Rust verisim-planner API when available, with local estimation as fallback.

**Original issue:** EXPLAIN returned a static plan with hardcoded step names and costs totalling 71ms, regardless of the actual query structure.

=== 19. VQL Executor Federation Stub — ✅ RESOLVED

**Location:** `elixir-orchestration/lib/verisim/query/vql_executor.ex`, `rust-core/verisim-api/src/federation.rs`

**Resolved:** 2026-02-13. Added `GET /hexads` list endpoint with `?limit=N&offset=M` pagination to the Rust API. The `HexadStore` trait now includes a `list(limit, offset)` method. Federation `query_single_peer()` now falls back to the `/hexads` list endpoint when neither text_query nor vector_query is provided, so bare `SELECT * FROM FEDERATION /pattern/*` returns actual hexad data instead of empty results.

=== 20. Custom Circuit Hardcoding — ✅ RESOLVED

**Location:** `rust-core/verisim-semantic/src/circuit_registry.rs`, `circuit_compiler.rs`, `verification_keys.rs`, `src/vql/VQLCircuit.res`

**Resolved:** 2026-02-13. Full custom circuit infrastructure implemented:

- Circuit Registry: named circuit storage with register/get/verify/list/unregister operations
- Circuit Compiler: DSL gates (AND, OR, XOR, NOT, LinearCombination) compiled to R1CS constraints
- Verification Key Store: per-circuit keys with rotation support and federation export/import
- VQL Circuit DSL: ReScript types for circuit definition with `PROOF CUSTOM "name" WITH (param=value)`
- 25 semantic tests pass covering circuit operations

**Original issue:** The `CUSTOM` proof type used a hardcoded circuit configuration with no DSL, compiler, or registry.

=== 21. VQL-DT Not Connected to VQL PROOF Runtime (OPEN)

**Location:** `vql-dt/` (Lean type definitions), VQL query router

**Current state:** Lean type definitions exist specifying dependent type contracts for all six PROOF types. The VQL parser parses `PROOF` clauses and the executor routes proofs through `verify_single_proof/1` which validates contract existence. However, the Lean type checker itself is not invoked at runtime. VQL-DT queries execute but proof certificates are not formally verified by the Lean checker.

**Impact:** PROOF clauses are semantically checked (contract existence, parameter validation) but not formally verified via the Lean dependent type checker. Custom ZKP circuits work (R1CS verification), but the VQL-DT formal path is not wired.

**Resolution:** Wire the Lean type checker into the VQL-DT execution path. See link:docs/vql-vs-vql-dt.adoc[VQL Slipstream vs VQL-DT].

=== 22. proven Library Not Integrated (OPEN)

**Location:** Design docs only

**Current state:** Custom ZKP circuits work via R1CS constraint systems with in-process verification. However, the `proven` library for generating actual zero-knowledge proofs (where a verifier can confirm a property without seeing the data) is not integrated.

**Impact:** Privacy-preserving proofs are not available. Current circuit verification requires the witness (private input) to be present, which defeats the zero-knowledge property.

**Resolution:** Integrate proven library after VQL-DT (issue 21) is resolved.

=== 23. verisim-repl Has Build Issues (OPEN — LOW)

**Location:** `rust-core/verisim-repl/`

**Current state:** The REPL crate was added by a linter with rustyline API incompatibilities (`Completer`, `Highlighter`, `Hinter`, `Validator` traits are private in the installed version). The workspace builds successfully with `--exclude verisim-repl`.

**Impact:** Low. The REPL is a developer convenience tool, not a core component.

**Resolution:** Update rustyline API calls to match installed version, or pin a compatible version.
