// SPDX-License-Identifier: PMPL-1.0-or-later
//! EXPLAIN output rendering (text and JSON).

use std::collections::HashMap;
use std::fmt;

use serde::{Deserialize, Serialize};

use crate::config::PlannerConfig;
use crate::plan::PhysicalPlan;
use crate::Modality;

/// Cost breakdown for a single modality.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModalityCostBreakdown {
    pub modality: Modality,
    pub time_ms: f64,
    pub percentage: f64,
}

/// A single step in the EXPLAIN output.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExplainStep {
    pub step: usize,
    pub operation: String,
    pub modality: Modality,
    pub estimated_cost_ms: f64,
    pub estimated_selectivity: f64,
    pub estimated_rows: u64,
    pub optimization_hint: Option<String>,
}

/// A performance hint generated by the planner.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerformanceHint {
    pub severity: String,
    pub message: String,
}

/// Full EXPLAIN output for a query plan.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExplainOutput {
    /// Per-step details.
    pub steps: Vec<ExplainStep>,
    /// Cost breakdown by modality.
    pub cost_breakdown: Vec<ModalityCostBreakdown>,
    /// Performance hints and suggestions.
    pub performance_hints: Vec<PerformanceHint>,
    /// Total estimated cost in milliseconds.
    pub total_cost_ms: f64,
    /// Execution strategy.
    pub strategy: String,
    /// Human-readable text rendering.
    pub text_output: String,
}

impl ExplainOutput {
    /// Build an ExplainOutput from a physical plan.
    pub fn from_physical_plan(plan: &PhysicalPlan, config: &PlannerConfig) -> Self {
        let steps: Vec<ExplainStep> = plan
            .steps
            .iter()
            .map(|s| ExplainStep {
                step: s.step,
                operation: s.operation.clone(),
                modality: s.modality,
                estimated_cost_ms: s.cost.time_ms,
                estimated_selectivity: s.cost.selectivity,
                estimated_rows: s.cost.estimated_rows,
                optimization_hint: s.optimization_hint.clone(),
            })
            .collect();

        // Build cost breakdown by modality
        let mut modality_costs: HashMap<Modality, f64> = HashMap::new();
        for step in &plan.steps {
            *modality_costs.entry(step.modality).or_insert(0.0) += step.cost.time_ms;
        }
        let total_modality_cost: f64 = modality_costs.values().sum();

        let mut cost_breakdown: Vec<ModalityCostBreakdown> = modality_costs
            .into_iter()
            .map(|(modality, time_ms)| {
                let percentage = if total_modality_cost > 0.0 {
                    (time_ms / total_modality_cost) * 100.0
                } else {
                    0.0
                };
                ModalityCostBreakdown {
                    modality,
                    time_ms,
                    percentage,
                }
            })
            .collect();
        cost_breakdown.sort_by(|a, b| b.percentage.partial_cmp(&a.percentage).unwrap_or(std::cmp::Ordering::Equal));

        // Generate performance hints
        let mut hints = Vec::new();

        // High total cost
        if plan.total_cost.time_ms > 500.0 {
            hints.push(PerformanceHint {
                severity: "warning".to_string(),
                message: format!(
                    "Total estimated cost is {:.0}ms — consider adding LIMIT clause",
                    plan.total_cost.time_ms
                ),
            });
        }

        // Check for expensive individual steps
        for step in &plan.steps {
            if step.cost.time_ms > 200.0 {
                hints.push(PerformanceHint {
                    severity: "info".to_string(),
                    message: format!(
                        "Step {} ({}) costs {:.0}ms — {}",
                        step.step,
                        step.modality,
                        step.cost.time_ms,
                        step.optimization_hint.as_deref().unwrap_or("consider optimization")
                    ),
                });
            }
        }

        // First step has poor selectivity
        if let Some(first) = plan.steps.first() {
            if first.cost.selectivity > 0.1 {
                hints.push(PerformanceHint {
                    severity: "suggestion".to_string(),
                    message: format!(
                        "First step ({}) has {:.0}% selectivity — consider reordering or adding predicates",
                        first.modality,
                        first.cost.selectivity * 100.0
                    ),
                });
            }
        }

        // Sequential when parallel is possible
        if plan.steps.len() >= 2
            && plan.strategy == crate::plan::ExecutionStrategy::Sequential
        {
            hints.push(PerformanceHint {
                severity: "suggestion".to_string(),
                message: "Multiple modalities could benefit from parallel execution".to_string(),
            });
        }

        let strategy = format!("{:?}", plan.strategy);
        let total_cost_ms = plan.total_cost.time_ms;

        // Build text output
        let text_output = Self::render_text(&steps, &cost_breakdown, &hints, &strategy, total_cost_ms, config);

        ExplainOutput {
            steps,
            cost_breakdown,
            performance_hints: hints,
            total_cost_ms,
            strategy,
            text_output,
        }
    }

    fn render_text(
        steps: &[ExplainStep],
        cost_breakdown: &[ModalityCostBreakdown],
        hints: &[PerformanceHint],
        strategy: &str,
        total_cost_ms: f64,
        _config: &PlannerConfig,
    ) -> String {
        let mut out = String::new();

        out.push_str("=== VeriSimDB Query Plan ===\n\n");
        out.push_str(&format!("Strategy: {}\n", strategy));
        out.push_str(&format!("Total Estimated Cost: {:.1}ms\n\n", total_cost_ms));

        out.push_str("--- Steps ---\n");
        for step in steps {
            out.push_str(&format!(
                "  Step {}: {} [{}]\n",
                step.step, step.operation, step.modality
            ));
            out.push_str(&format!(
                "    Cost: {:.1}ms | Selectivity: {:.2}% | Rows: ~{}\n",
                step.estimated_cost_ms,
                step.estimated_selectivity * 100.0,
                step.estimated_rows
            ));
            if let Some(hint) = &step.optimization_hint {
                out.push_str(&format!("    Hint: {}\n", hint));
            }
        }

        out.push_str("\n--- Cost Breakdown ---\n");
        for cb in cost_breakdown {
            out.push_str(&format!(
                "  {}: {:.1}ms ({:.1}%)\n",
                cb.modality, cb.time_ms, cb.percentage
            ));
        }

        if !hints.is_empty() {
            out.push_str("\n--- Performance Hints ---\n");
            for hint in hints {
                out.push_str(&format!("  [{}] {}\n", hint.severity, hint.message));
            }
        }

        out
    }
}

impl fmt::Display for ExplainOutput {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.text_output)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::cost::CostEstimate;
    use crate::plan::{ExecutionStrategy, PhysicalPlan, PlanStep};

    fn sample_physical_plan() -> PhysicalPlan {
        PhysicalPlan {
            steps: vec![
                PlanStep {
                    step: 1,
                    operation: "Vector similarity search (1 conditions)".to_string(),
                    modality: Modality::Vector,
                    cost: CostEstimate {
                        time_ms: 40.0,
                        estimated_rows: 10,
                        selectivity: 0.005,
                        io_cost: 24.0,
                        cpu_cost: 16.0,
                    },
                    optimization_hint: Some("HNSW ANN search (k=10)".to_string()),
                    pushed_predicates: vec!["Similarity { k: 10 }".to_string()],
                },
                PlanStep {
                    step: 2,
                    operation: "Graph traversal (1 conditions)".to_string(),
                    modality: Modality::Graph,
                    cost: CostEstimate {
                        time_ms: 225.0,
                        estimated_rows: 200,
                        selectivity: 0.4,
                        io_cost: 135.0,
                        cpu_cost: 90.0,
                    },
                    optimization_hint: Some("Graph traversal: relates_to (depth=2)".to_string()),
                    pushed_predicates: vec!["Traversal { predicate: relates_to }".to_string()],
                },
            ],
            strategy: ExecutionStrategy::Parallel,
            total_cost: CostEstimate {
                time_ms: 225.0,
                estimated_rows: 200,
                selectivity: 0.002,
                io_cost: 159.0,
                cpu_cost: 106.0,
            },
            notes: vec!["Parallel execution across 2 modalities".to_string()],
        }
    }

    #[test]
    fn test_step_count() {
        let plan = sample_physical_plan();
        let explain = ExplainOutput::from_physical_plan(&plan, &PlannerConfig::default());
        assert_eq!(explain.steps.len(), 2);
    }

    #[test]
    fn test_cost_percentages_sum_to_100() {
        let plan = sample_physical_plan();
        let explain = ExplainOutput::from_physical_plan(&plan, &PlannerConfig::default());

        let total_pct: f64 = explain.cost_breakdown.iter().map(|cb| cb.percentage).sum();
        assert!(
            (total_pct - 100.0).abs() < 0.1,
            "Cost percentages sum to {}, expected ~100",
            total_pct
        );
    }

    #[test]
    fn test_text_output_contains_sections() {
        let plan = sample_physical_plan();
        let explain = ExplainOutput::from_physical_plan(&plan, &PlannerConfig::default());

        assert!(explain.text_output.contains("VeriSimDB Query Plan"));
        assert!(explain.text_output.contains("Strategy"));
        assert!(explain.text_output.contains("Steps"));
        assert!(explain.text_output.contains("Cost Breakdown"));
        assert!(explain.text_output.contains("Step 1"));
        assert!(explain.text_output.contains("Step 2"));
        assert!(explain.text_output.contains("vector"));
        assert!(explain.text_output.contains("graph"));
    }

    #[test]
    fn test_performance_hints_for_expensive() {
        // Create a plan with a very expensive step
        let plan = PhysicalPlan {
            steps: vec![PlanStep {
                step: 1,
                operation: "Semantic verification".to_string(),
                modality: Modality::Semantic,
                cost: CostEstimate {
                    time_ms: 675.0,
                    estimated_rows: 800,
                    selectivity: 0.8,
                    io_cost: 405.0,
                    cpu_cost: 270.0,
                },
                optimization_hint: Some("ZKP verification — expensive".to_string()),
                pushed_predicates: vec![],
            }],
            strategy: ExecutionStrategy::Sequential,
            total_cost: CostEstimate {
                time_ms: 675.0,
                estimated_rows: 800,
                selectivity: 0.8,
                io_cost: 405.0,
                cpu_cost: 270.0,
            },
            notes: vec![],
        };

        let explain = ExplainOutput::from_physical_plan(&plan, &PlannerConfig::default());
        assert!(!explain.performance_hints.is_empty());

        // Should have warning about high cost
        let has_cost_warning = explain
            .performance_hints
            .iter()
            .any(|h| h.message.contains("LIMIT"));
        assert!(has_cost_warning);
    }

    #[test]
    fn test_explain_json_roundtrip() {
        let plan = sample_physical_plan();
        let explain = ExplainOutput::from_physical_plan(&plan, &PlannerConfig::default());

        let json = serde_json::to_string(&explain).unwrap();
        let parsed: ExplainOutput = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed.steps.len(), explain.steps.len());
        assert!((parsed.total_cost_ms - explain.total_cost_ms).abs() < f64::EPSILON);
    }

    #[test]
    fn test_display_trait() {
        let plan = sample_physical_plan();
        let explain = ExplainOutput::from_physical_plan(&plan, &PlannerConfig::default());
        let display = format!("{}", explain);
        assert!(!display.is_empty());
        assert!(display.contains("VeriSimDB"));
    }
}
