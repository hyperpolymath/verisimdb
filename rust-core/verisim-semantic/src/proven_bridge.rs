// SPDX-License-Identifier: PMPL-1.0-or-later
// Copyright (c) 2026 Jonathan D.A. Jewell (hyperpolymath) <jonathan.jewell@open.ac.uk>
//! Proven Bridge — Integration with the `proven` library (Idris2 ZKP system).
//!
//! The `proven` library uses Idris2 dependent types with Zig FFI to provide
//! formally verified proofs. Rather than linking the Idris2 runtime directly,
//! VeriSimDB consumes proof certificates that `proven` generates as JSON/CBOR
//! files, verifies their structure, and stores them in the semantic modality.
//!
//! # Certificate Format
//!
//! ```json
//! {
//!   "version": "1.0",
//!   "prover": "z3",
//!   "statement": "forall x : Nat, x + 0 = x",
//!   "proof_term": "refl",
//!   "valid": true,
//!   "timestamp": "2026-02-13T12:00:00Z",
//!   "signature": "sha256:abcdef..."
//! }
//! ```
//!
//! # Architecture
//!
//! ```text
//! proven (Idris2/Zig) → JSON certificate → ProvenBridge → SemanticStore
//!                                              │
//!                                    ┌─────────┴──────────┐
//!                                    │ ProvenCertificate   │
//!                                    │  - parse            │
//!                                    │  - verify_structure │
//!                                    │  - to_proof_blob    │
//!                                    └────────────────────┘
//! ```

use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};

use super::{ProofBlob, ProofType, SemanticError};

/// Supported prover backends from the proven library.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ProverKind {
    /// Z3 SMT solver
    Z3,
    /// Lean 4 theorem prover
    Lean,
    /// Coq proof assistant
    Coq,
    /// Agda dependently-typed prover
    Agda,
    /// Idris2 native (totality checker)
    Idris2,
    /// Custom/external prover
    Custom(String),
}

impl std::fmt::Display for ProverKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Z3 => write!(f, "z3"),
            Self::Lean => write!(f, "lean"),
            Self::Coq => write!(f, "coq"),
            Self::Agda => write!(f, "agda"),
            Self::Idris2 => write!(f, "idris2"),
            Self::Custom(name) => write!(f, "custom:{}", name),
        }
    }
}

/// A proof certificate generated by the proven library.
///
/// Represents a formally verified proof statement with its proof term
/// and verification metadata. Can be stored in VeriSimDB as a `ProofBlob`
/// in the semantic modality.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProvenCertificate {
    /// Certificate format version.
    pub version: String,
    /// Which prover produced this certificate.
    pub prover: ProverKind,
    /// The formal statement being proven.
    pub statement: String,
    /// The proof term (prover-specific representation).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub proof_term: Option<String>,
    /// Whether the proof was verified as valid.
    pub valid: bool,
    /// Optional verification message.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// ISO 8601 timestamp of proof generation.
    pub timestamp: String,
    /// Content-addressable signature: sha256 of (prover + statement + proof_term).
    pub signature: String,
}

impl ProvenCertificate {
    /// Compute the expected signature for a certificate.
    fn compute_signature(prover: &ProverKind, statement: &str, proof_term: Option<&str>) -> String {
        let mut hasher = Sha256::new();
        hasher.update(prover.to_string().as_bytes());
        hasher.update(b":");
        hasher.update(statement.as_bytes());
        hasher.update(b":");
        hasher.update(proof_term.unwrap_or("").as_bytes());
        format!("sha256:{}", hex::encode(hasher.finalize()))
    }
}

/// Parse a proven certificate from JSON bytes.
pub fn parse_proven_certificate(bytes: &[u8]) -> Result<ProvenCertificate, SemanticError> {
    serde_json::from_slice(bytes)
        .map_err(|e| SemanticError::SerializationError(format!("Failed to parse proven certificate: {}", e)))
}

/// Parse a proven certificate from CBOR bytes.
pub fn parse_proven_certificate_cbor(bytes: &[u8]) -> Result<ProvenCertificate, SemanticError> {
    ciborium::from_reader(bytes)
        .map_err(|e| SemanticError::SerializationError(format!("Failed to parse proven certificate (CBOR): {}", e)))
}

/// Verify the structural integrity of a proven certificate.
///
/// Checks:
/// - Version is supported ("1.0")
/// - Signature matches the computed hash of (prover, statement, proof_term)
/// - Timestamp is a valid RFC 3339 datetime
pub fn verify_proven_certificate(cert: &ProvenCertificate) -> Result<bool, SemanticError> {
    // Check version
    if cert.version != "1.0" {
        return Err(SemanticError::InvalidProof(format!(
            "Unsupported certificate version: {}",
            cert.version
        )));
    }

    // Verify signature
    let expected_sig = ProvenCertificate::compute_signature(
        &cert.prover,
        &cert.statement,
        cert.proof_term.as_deref(),
    );
    if cert.signature != expected_sig {
        return Ok(false);
    }

    // Verify timestamp is parseable
    chrono::DateTime::parse_from_rfc3339(&cert.timestamp)
        .map_err(|e| SemanticError::InvalidProof(format!("Invalid timestamp: {}", e)))?;

    Ok(cert.valid)
}

/// Convert a proven certificate into a VeriSimDB ProofBlob for storage
/// in the semantic modality.
pub fn certificate_to_proof_blob(cert: &ProvenCertificate) -> Result<ProofBlob, SemanticError> {
    let data = serde_json::to_vec(cert)
        .map_err(|e| SemanticError::SerializationError(e.to_string()))?;

    Ok(ProofBlob {
        claim: cert.statement.clone(),
        proof_type: ProofType::Attestation,
        data,
        timestamp: cert.timestamp.clone(),
    })
}

/// Create a new ProvenCertificate with computed signature.
///
/// Used when generating certificates from VeriSimDB-side proof operations.
pub fn create_certificate(
    prover: ProverKind,
    statement: String,
    proof_term: Option<String>,
    valid: bool,
    message: Option<String>,
) -> ProvenCertificate {
    let signature = ProvenCertificate::compute_signature(
        &prover,
        &statement,
        proof_term.as_deref(),
    );

    ProvenCertificate {
        version: "1.0".to_string(),
        prover,
        statement,
        proof_term,
        valid,
        message,
        timestamp: chrono::Utc::now().to_rfc3339(),
        signature,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample_certificate() -> ProvenCertificate {
        create_certificate(
            ProverKind::Z3,
            "forall x : Nat, x + 0 = x".to_string(),
            Some("refl".to_string()),
            true,
            None,
        )
    }

    #[test]
    fn test_certificate_roundtrip_json() {
        let cert = sample_certificate();
        let json = serde_json::to_vec(&cert).unwrap();
        let parsed = parse_proven_certificate(&json).unwrap();
        assert_eq!(parsed.statement, cert.statement);
        assert_eq!(parsed.prover, ProverKind::Z3);
    }

    #[test]
    fn test_certificate_roundtrip_cbor() {
        let cert = sample_certificate();
        let mut cbor = Vec::new();
        ciborium::into_writer(&cert, &mut cbor).unwrap();
        let parsed = parse_proven_certificate_cbor(&cbor).unwrap();
        assert_eq!(parsed.statement, cert.statement);
    }

    #[test]
    fn test_verify_valid_certificate() {
        let cert = sample_certificate();
        assert!(verify_proven_certificate(&cert).unwrap());
    }

    #[test]
    fn test_verify_invalid_signature() {
        let mut cert = sample_certificate();
        cert.signature = "sha256:0000000000000000000000000000000000000000000000000000000000000000".to_string();
        assert!(!verify_proven_certificate(&cert).unwrap());
    }

    #[test]
    fn test_verify_invalid_version() {
        let mut cert = sample_certificate();
        cert.version = "2.0".to_string();
        assert!(verify_proven_certificate(&cert).is_err());
    }

    #[test]
    fn test_certificate_to_proof_blob() {
        let cert = sample_certificate();
        let blob = certificate_to_proof_blob(&cert).unwrap();
        assert_eq!(blob.claim, cert.statement);
        assert!(!blob.data.is_empty());
    }

    #[test]
    fn test_invalid_certificate_not_valid() {
        let cert = create_certificate(
            ProverKind::Lean,
            "false".to_string(),
            None,
            false,
            Some("Proof failed".to_string()),
        );
        assert!(!verify_proven_certificate(&cert).unwrap());
    }

    #[test]
    fn test_prover_kind_display() {
        assert_eq!(ProverKind::Z3.to_string(), "z3");
        assert_eq!(ProverKind::Lean.to_string(), "lean");
        assert_eq!(ProverKind::Custom("myprover".to_string()).to_string(), "custom:myprover");
    }
}
